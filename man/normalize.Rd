% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normalize.R
\name{normalize}
\alias{normalize}
\alias{quantile_normalize_dm}
\alias{quantile_normalize_df}
\alias{normalize_sample_medians_dm}
\alias{normalize_sample_medians_df}
\alias{normalize_data_dm}
\alias{normalize_data_df}
\title{Data normalization methods}
\usage{
quantile_normalize_dm(data_matrix)

quantile_normalize_df(df_long, feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName", measure_col = "Intensity",
  no_fit_imputed = TRUE, qual_col = NULL, qual_value = 2,
  keep_all = "default")

normalize_sample_medians_dm(data_matrix)

normalize_sample_medians_df(df_long,
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName", measure_col = "Intensity",
  no_fit_imputed = FALSE, qual_col = NULL, qual_value = 2,
  keep_all = "default")

normalize_data_dm(data_matrix, normalize_func = c("quantile",
  "medianCentering"), log_base = NULL, offset = 1)

normalize_data_df(df_long, normalize_func = c("quantile",
  "medianCentering"), log_base = NULL, offset = 1,
  feature_id_col = "peptide_group_label",
  sample_id_col = "FullRunName", measure_col = "Intensity",
  no_fit_imputed = TRUE, qual_col = NULL, qual_value = 2,
  keep_all = "default")
}
\arguments{
\item{data_matrix}{features (in rows) vs samples (in columns) matrix, with
feature IDs in rownames and file/sample names as colnames. 
See "example_proteome_matrix" for more details (to call the description, 
use \code{help("example_proteome_matrix")})}

\item{df_long}{data frame where each row is a single feature in a single
sample. It minimally has a \code{sample_id_col}, a \code{feature_id_col} 
and a \code{measure_col}, but usually also an \code{m_score} (in OpenSWATH 
output result file). See \code{help("example_proteome")} for more details.}

\item{feature_id_col}{name of the column with feature/gene/peptide/protein
ID used in the long format representation \code{df_long}. In the wide
formatted representation \code{data_matrix} this corresponds to the row
names.}

\item{sample_id_col}{name of the column in \code{sample_annotation} table, 
where the filenames (colnames of the \code{data_matrix} are found).}

\item{measure_col}{if \code{df_long} is among the parameters, it is the
column with expression/abundance/intensity; otherwise, it is used
internally for consistency.}

\item{no_fit_imputed}{(logical) whether to use imputed (requant) values, as flagged in 
\code{qual_col} by \code{qual_value} for data transformation}

\item{qual_col}{column to color point by certain value denoted 
by \code{qual_value}. Design with inferred/requant values in 
OpenSWATH output data, 
which means argument value has to be set to \code{m_score}.}

\item{qual_value}{value in \code{qual_col} to color. For OpenSWATH data,
this argument value has to be set to \code{2} (this is an \code{m_score} 
value for imputed values (requant values).}

\item{keep_all}{when transforming the data (normalize, correct) - acceptable 
values: all/default/minimal (which set of columns be kept).}

\item{normalize_func}{global batch normalization method 
(`quantile` or `MedianCentering`)}

\item{log_base}{whether to log transform data matrix 
before normalization (e.g. `NULL`, `2` or `10`)}

\item{offset}{small positive number to prevent 0 conversion to \code{-Inf}}
}
\value{
the data in the same format as input (\code{data_matrix} or 
\code{df_long}).
For \code{df_long} the data frame stores the original values of 
\code{measure_col}
in another column called "preNorm_intensity" if "intensity", and the 
normalized values in \code{measure_col} column.
}
\description{
Normalization of raw (usually log-transformed) data. 
Normalization brings the samples to the same scale.
Currently the following normalization functions are implemented:
#' \enumerate{
  \item Quantile normalization: `quantile_normalize_dm()`. 
  Quantile normalization of the data.
  \item Median normalization: `normalize_sample_medians_dm()`. 
  Normalization by centering sample medians to global median of the data
}
Alternatively, one can call normalization function with `normalize_data_dm()` 
wrapper.
}
\examples{

#Quantile normalization:
quantile_normalized_matrix <- quantile_normalize_dm(example_proteome_matrix)

#Median centering:
median_normalized_df <- normalize_sample_medians_df(example_proteome)

#Transform the data in one go:
quantile_normalized_matrix <- normalize_data_dm(example_proteome_matrix, 
normalize_func = "quantile", log_base = 2, offset = 1)

}
